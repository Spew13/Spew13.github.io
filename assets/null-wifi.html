<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>NullBot - Popup Takeover</title>
<style>
  :root { --bg:#050607; --lime:#7CFF4F; --muted:#8a9398; }
  html,body{height:100%;margin:0;background:var(--bg);font-family:monospace;color:var(--lime);overflow:hidden}
  /* popup base */
  .nb-popup{
    position:fixed;
    width:320px;
    min-height:120px;
    padding:12px 12px 14px 12px;
    background: rgba(0,10,0,0.92);
    box-shadow: 0 8px 30px rgba(0,0,0,0.7), 0 0 18px rgba(124,255,79,0.06) inset;
    border-radius:8px;
    z-index:99999;
    color:var(--lime);
    text-shadow:0 0 6px rgba(124,255,79,0.12);
    overflow:hidden;
  }
  .nb-popup .close {
    position:absolute; right:8px; top:6px;
    color:var(--muted); background:transparent; border:0; font-size:18px; cursor:pointer;
  }
  .nb-title{ font-weight:700; margin-bottom:8px; color:var(--lime); font-size:13px; display:flex; justify-content:space-between; align-items:center;}
  .nb-body{ font-size:13px; line-height:1.25; white-space:pre-wrap; max-height:220px; overflow:auto; padding-right:6px;}
  .cursor { display:inline-block; width:8px; height:14px; background:var(--lime); vertical-align:bottom; animation:blink 1s step-start infinite; margin-left:4px;}
  @keyframes blink{0%,50%{opacity:1;}50.1%,100%{opacity:0}}
  /* glitch letter */
  .g { display:inline-block; animation:gl 0.25s infinite; }
  @keyframes gl { 0%{transform:translate(0,0)} 30%{transform:translate(-1px,1px)} 60%{transform:translate(1px,-1px)} 100%{transform:translate(0,0)}}
  /* wifi bars */
  .wifi-bars { margin-top:8px; display:flex; align-items:end; justify-content:center; gap:6px; height:36px;}
  .bar{ width:12px; background:var(--lime); transition:height 220ms cubic-bezier(.2,.9,.2,1), background 220ms; border-radius:3px;}
  .bar.off{ background:transparent }
  .bar.flash{ background:#ff4444 }
  .status { text-align:center; margin-top:6px; color:var(--lime); font-size:13px; }
  /* loader */
  .loader-track{ width:100%; height:12px; background:rgba(0,0,0,0.25); border-radius:8px; margin-top:12px; overflow:hidden}
  .loader-fill{ height:100%; width:0%; background:linear-gradient(90deg,var(--lime), rgba(124,255,79,0.6)); transition:width 420ms linear}
  .loader-stalled{ animation:stallPulse 1s infinite; }
  @keyframes stallPulse { 0%{box-shadow:0 0 0 rgba(124,255,79,0.05)} 50%{box-shadow:0 0 12px rgba(255,68,68,0.18)} 100%{box-shadow:0 0 0 rgba(124,255,79,0.05)} }
  /* small hint */
  .muted{ color:var(--muted); font-size:12px; margin-top:10px; display:block }
</style>
</head>
<body>

<script>
// ---------- helper utilities ----------
function randomIn(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
function placePopup(el){
  const pad=18;
  const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
  const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
  const x = randomIn(pad, Math.max(pad, vw - el.offsetWidth - pad));
  const y = randomIn(pad, Math.max(pad, vh - el.offsetHeight - pad));
  el.style.left = x + "px";
  el.style.top = y + "px";
}

// create base popup
function makePopup(titleText){
  const p = document.createElement('div'); p.className='nb-popup';
  const t = document.createElement('div'); t.className='nb-title';
  t.innerHTML = `<span>${titleText}</span>`;
  const btn = document.createElement('button'); btn.className='close'; btn.innerHTML='✕';
  btn.onclick = ()=>p.remove();
  t.appendChild(btn);
  const b = document.createElement('div'); b.className='nb-body';
  p.appendChild(t); p.appendChild(b);
  document.body.appendChild(p);
  // position after appended so offsetWidth/Height are available
  placePopup(p);
  return {el:p,body:b,title:t};
}

// ---------- Terminal popup (types Linux commands) ----------
function spawnTerminalPopup(){
  const {el,body} = makePopup('terminal@nullbot');
  // small terminal prompt area
  const prompt = document.createElement('div'); body.appendChild(prompt);
  const cursor = document.createElement('span'); cursor.className='cursor';
  prompt.appendChild(cursor);

  const cmds = [
    "whoami",
    "uname -a",
    "ps aux --forest",
    "dmesg | tail -n 20",
    "cat /var/log/syslog | tail -n 8",
    "find / -type f -name '*.conf' 2>/dev/null",
    "echo 'NullBot presence: confirmed.'",
    "netstat -tunapl | grep ESTABLISHED",
    "watch -n 1 'echo scanning...'",
    "tail -f /var/log/auth.log"
  ];

  // cosmetic typewriter for terminal
  function typeText(el, text, i=0, fast=true, cb){
    if(i>=text.length){ if(cb) setTimeout(cb, 120); return; }
    // small chance to render 'glitch' span
    const ch = text[i];
    if(Math.random()<0.07){
      const span = document.createElement('span'); span.className='g'; span.textContent = ch; el.appendChild(span);
    } else {
      el.appendChild(document.createTextNode(ch));
    }
    el.scrollTop = el.scrollHeight;
    const delay = fast ? randomIn(6,20) : randomIn(30,80);
    setTimeout(()=>typeText(el,text,i+1,fast,cb), delay);
  }

  // run commands in sequence, looped and fast
  let idx = 0;
  function runNext(){
    if(!document.body.contains(el)) return; // popup closed
    const line = document.createElement('div'); body.insertBefore(line, prompt);
    const cmd = cmds[idx % cmds.length];
    typeText(line, `$ ${cmd}`, 0, true, ()=>{
      // after command, show fake output
      setTimeout(()=>{
        const out = document.createElement('div'); out.style.color='#b5ffd0';
        const fakeOut = [
          "output: OK",
          "connection: 127.0.0.1 -> 10.0.0.2 ESTABLISHED",
          "log: permission denied (simulated)",
          "scan: ports 22,80,443 open",
          "memory: patterns learned"
        ][randomIn(0,4)];
        out.textContent = fakeOut;
        body.insertBefore(out, prompt);
        // keep popup scrolling
        body.scrollTop = body.scrollHeight;
        idx++;
        // short random delay before next command
        setTimeout(runNext, randomIn(200,800));
      }, randomIn(80,220));
    });
  }
  // start quickly
  setTimeout(runNext, 200);
}

// ---------- Wi-Fi popup (bars animate 4->5->0->flash red -> NullBot Connected) ----------
function spawnWifiPopup(){
  const {el,body} = makePopup('wireless-manager');
  // status
  const status = document.createElement('div'); status.className='status'; status.textContent='Wi-Fi: connected (authenticating...)';
  body.appendChild(status);
  // bars
  const barsWrap = document.createElement('div'); barsWrap.className='wifi-bars';
  const bars = [];
  for(let i=0;i<5;i++){ const bar = document.createElement('div'); bar.className='bar off'; bar.style.height='8px'; bars.push(bar); barsWrap.appendChild(bar); }
  body.appendChild(barsWrap);

  function setBars(n, colorClass){
    bars.forEach((b,i)=>{
      if(i<n){
        b.classList.remove('off'); b.style.height = (8 + i*6) + 'px';
        b.classList.remove('flash'); b.style.background = 'var(--lime)';
        if(colorClass==='flash') b.classList.add('flash');
      } else {
        b.classList.add('off'); b.style.height='8px'; b.style.background='transparent';
        b.classList.remove('flash');
      }
    });
  }

  // animation sequence: 4 -> 5 -> 0 -> flash red -> end connected
  setTimeout(()=>setBars(4), 400);
  setTimeout(()=>setBars(5), 1100);
  setTimeout(()=>{ setBars(0); status.textContent='Wi-Fi: connection unstable'; }, 1700);
  setTimeout(()=>{ setBars(5); /* flash red then warning */ }, 2200);
  setTimeout(()=>{ bars.forEach(b=>b.classList.add('flash')); status.textContent='WARNING: unauthorized endpoint detected'; }, 2600);
  setTimeout(()=>{
    // finalize message
    bars.forEach(b=>{ b.classList.remove('flash'); b.style.background='var(--lime)'; });
    setBars(5);
    status.textContent = 'NullBot Connected';
  }, 3200);
}

// ---------- Loader popup (stalls ~95%) ----------
function spawnLoaderPopup(){
  const {el,body} = makePopup('module-loader');
  const hint = document.createElement('div'); hint.className='muted'; hint.textContent='Loading module: /sys/nullbot/core';
  body.appendChild(hint);
  const track = document.createElement('div'); track.className='loader-track';
  const fill = document.createElement('div'); fill.className='loader-fill';
  track.appendChild(fill);
  body.appendChild(track);
  const status = document.createElement('div'); status.className='status'; status.textContent='Initializing...';
  body.appendChild(status);

  // fill to ~95% quick, then tiny increments & stall
  let progress = 0;
  function step(){
    if(progress < 75){
      progress += randomIn(6,14);
    } else if(progress < 95){
      progress += randomIn(2,6);
    } else {
      // stall: tiny jitter increments that never reach 100, make a stalling animation
      progress += Math.random() < 0.25 ? randomIn(0,1) : 0;
    }
    if(progress > 99) progress = 99;
    fill.style.width = progress + '%';
    // change status messages
    if(progress < 30) status.textContent = 'Allocating memory...';
    else if(progress < 60) status.textContent = 'Loading dependencies...';
    else if(progress < 90) status.textContent = 'Decrypting payload...';
    else status.textContent = 'Finalizing... (pending)';
    // add a stalled class when >=95
    if(progress >= 95) fill.classList.add('loader-stalled');
    if(document.body.contains(el)) setTimeout(step, randomIn(200,700));
  }
  setTimeout(step, 200);
}

// ---------- orchestrator: spawn 3 popups immediately (within ~5s) ----------
function startTakeoverImmediately(){
  // spawn 3 popups within ~5s, with slight random offsets/ordering
  const spawnFns = [spawnTerminalPopup, spawnWifiPopup, spawnLoaderPopup];
  // shuffle for random ordering
  for (let i = spawnFns.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [spawnFns[i], spawnFns[j]] = [spawnFns[j], spawnFns[i]];
  }
  // schedule each within a 5s window
  spawnFns.forEach((fn) => {
    const offset = randomIn(0, 250); // 0 - 2.5s
    setTimeout(fn, offset);
  });
}

// kick it off immediately
startTakeoverImmediately();
      // ---------- orchestrator: spawn 17 popups immediately and randomly ----------
function startMassTakeover(){
  const TOTAL_POPUPS = 17;
  const spawnFns = [
    spawnTerminalPopup, 
    spawnWifiPopup, 
    spawnLoaderPopup
  ];

  console.log('Initiating spawning of', TOTAL_POPUPS, 'popups...');

  // Spawn 17 popups, selecting randomly from the three types
  for (let i = 0; i < TOTAL_POPUPS; i++) {
    // Select a random function from the list
    const randomFnIndex = randomIn(0, spawnFns.length - 1);
    const fn = spawnFns[randomFnIndex];

    // Schedule each to spawn within the first 5 seconds for a clustered effect
    const offset = randomIn(0, 5000); // 0 - 5s
    setTimeout(fn, offset);
  }
}

// kick it off immediately
startMassTakeover();

// The FIX section for triggering the 'crash' will now start its monitoring
// immediately and wait for the popups to appear before starting its 15-20s timer.
// ... (The rest of your code, including the FIX section, remains unchanged) ...
      
(function(){
  // don't schedule twice
  if (window._nb_crash_after_popups_scheduled) return;
  window._nb_crash_after_popups_scheduled = true;

  const REQUIRED_POPUPS = 3;
  const MIN_DELAY = 15000; // 15s
  const MAX_DELAY = 20000; // 20s
  let scheduled = false;
  let timeoutId = null;

  function callCrash() {
    // Prefer an exposed function, fallback to custom event
    if (typeof window.triggerCrash === 'function') {
      try { window.triggerCrash(); } catch (e) { console.error('triggerCrash threw:', e); }
    } else {
      window.dispatchEvent(new CustomEvent('nb-trigger-crash'));
    }
  }

  function scheduleAfterDelay() {
    if (scheduled) return;
    scheduled = true;
    const delay = Math.floor(Math.random() * (MAX_DELAY - MIN_DELAY + 1)) + MIN_DELAY;
    timeoutId = setTimeout(callCrash, delay);
    // optional: expose id for debug/cancel
    window._nb_crash_after_popups_timeout = timeoutId;
    console.log('[NullBot] crash scheduled to run in', delay, 'ms after popups detected');
  }

  function countPopups() {
    return document.querySelectorAll('.nb-popup').length;
  }

  // immediate check (in case popups already present)
  if (countPopups() >= REQUIRED_POPUPS) {
    scheduleAfterDelay();
    return;
  }

  // observe DOM until we see the required number of popups
  const obs = new MutationObserver(() => {
    if (countPopups() >= REQUIRED_POPUPS) {
      scheduleAfterDelay();
      obs.disconnect();
    }
  });

  obs.observe(document.body, { childList: true, subtree: true });

  // safety: stop observing if nothing happens in 60s
  const safety = setTimeout(() => {
    try { obs.disconnect(); } catch(e) {}
    if (!scheduled) {
      console.warn('[NullBot] no popup burst detected within 60s — crash not scheduled.');
    }
  }, 60000);

  // cleanup when crash fires or is cancelled
  function cleanup() {
    try { obs.disconnect(); } catch(e){}
    clearTimeout(safety);
  }

  // attach cleanup to window so other code can cancel if needed
  window._nb_crash_after_popups_cancel = function() {
    if (timeoutId) clearTimeout(timeoutId);
    cleanup();
    scheduled = false;
    window._nb_crash_after_popups_scheduled = false;
    delete window._nb_crash_after_popups_timeout;
    console.log('[NullBot] crash schedule cancelled');
  };

  // ensure cleanup after crash triggers
  (function monitorTrigger() {
    const original = window.triggerCrash;
    // If triggerCrash is a function, wrap it so we cleanup after it's called.
    if (typeof original === 'function') {
      window.triggerCrash = function(...args){
        try { return original.apply(this, args); } finally { cleanup(); }
      };
    } else {
      // if not present, listen for custom event and cleanup after it fires
      const once = () => { cleanup(); window.removeEventListener('nb-trigger-crash', once); };
      window.addEventListener('nb-trigger-crash', once);
    }
  })();

})();
// ---------- FIX: trigger crash 15-20s AFTER the 3 NullBot popups appear ----------
// Paste this after your existing popup-spawn script (or at the end of the page).
// It waits until there are at least 3 elements with class ".nb-popup" and then
// starts a single 15-20s timer. When the timer fires it calls window.triggerCrash()
// if available, otherwise it dispatches the "nb-trigger-crash" event.

(function(){
  // don't schedule twice
  if (window._nb_crash_after_popups_scheduled) return;
  window._nb_crash_after_popups_scheduled = true;

  const REQUIRED_POPUPS = 3;
  const MIN_DELAY = 15000; // 15s
  const MAX_DELAY = 20000; // 20s
  let scheduled = false;
  let timeoutId = null;

  function callCrash() {
    // Prefer an exposed function, fallback to custom event
    if (typeof window.triggerCrash === 'function') {
      try { window.triggerCrash(); } catch (e) { console.error('triggerCrash threw:', e); }
    } else {
      window.dispatchEvent(new CustomEvent('nb-trigger-crash'));
    }
  }

  function scheduleAfterDelay() {
    if (scheduled) return;
    scheduled = true;
    const delay = Math.floor(Math.random() * (MAX_DELAY - MIN_DELAY + 1)) + MIN_DELAY;
    timeoutId = setTimeout(callCrash, delay);
    // optional: expose id for debug/cancel
    window._nb_crash_after_popups_timeout = timeoutId;
    console.log('[NullBot] crash scheduled to run in', delay, 'ms after popups detected');
  }

  function countPopups() {
    return document.querySelectorAll('.nb-popup').length;
  }

  // immediate check (in case popups already present)
  if (countPopups() >= REQUIRED_POPUPS) {
    scheduleAfterDelay();
    return;
  }

  // observe DOM until we see the required number of popups
  const obs = new MutationObserver(() => {
    if (countPopups() >= REQUIRED_POPUPS) {
      scheduleAfterDelay();
      obs.disconnect();
    }
  });

  obs.observe(document.body, { childList: true, subtree: true });

  // safety: stop observing if nothing happens in 60s
  const safety = setTimeout(() => {
    try { obs.disconnect(); } catch(e) {}
    if (!scheduled) {
      console.warn('[NullBot] no popup burst detected within 60s — crash not scheduled.');
    }
  }, 60000);

  // cleanup when crash fires or is cancelled
  function cleanup() {
    try { obs.disconnect(); } catch(e){}
    clearTimeout(safety);
  }

  // attach cleanup to window so other code can cancel if needed
  window._nb_crash_after_popups_cancel = function() {
    if (timeoutId) clearTimeout(timeoutId);
    cleanup();
    scheduled = false;
    window._nb_crash_after_popups_scheduled = false;
    delete window._nb_crash_after_popups_timeout;
    console.log('[NullBot] crash schedule cancelled');
  };

  // ensure cleanup after crash triggers
  (function monitorTrigger() {
    const original = window.triggerCrash;
    // If triggerCrash is a function, wrap it so we cleanup after it's called.
    if (typeof original === 'function') {
      window.triggerCrash = function(...args){
        try { return original.apply(this, args); } finally { cleanup(); }
      };
    } else {
      // if not present, listen for custom event and cleanup after it fires
      const once = () => { cleanup(); window.removeEventListener('nb-trigger-crash', once); };
      window.addEventListener('nb-trigger-crash', once);
    }
  })();

})();

</script>

</body>
</html>
